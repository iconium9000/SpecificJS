tok:newaddlst; # creates new list, adds ret to list
tok:addlst; # adds ret to list
tok:endlst; # sets ret to list
tok:addendlst; # adds ret to list, sets ret to list
tok:emptylst; # sets ret to emptylst

tok:catch jump:int;
# push jump onto catch
# if err is thrown, pops catch moves state forward by jump
tok:endcatch; # pops catch
tok:err; # pops catch and throws err
tok:jump jump:int; # moves state forward by jump

tok:newsave; # saves current state as a checkpoint
tok:endsave; # forgets checkpoint

tok:schar; # reads a char as a special char and moves state forward
tok:char; # reads a char and moves state forward
tok:cmp cmp:{forEach c}:int jump:int;
# reads a char c
# if c does not exist in map, goto jump
# else moves state forward by cmp[c]

tok:arg; # sets arg to ret

tok:txt txt:string; # sets ret to txt

tok:emptyary; # sets ret to
tok:newary;
tok:addary;
tok:endary;

tok:str;
tok:pad;

tok:fout;
tok:out;

tok:newstk;
tok:addstk;
tok:endstk;

tok:newmap;
tok:addkey;
tok:addmap;
tok:endmap;

tok:act;
