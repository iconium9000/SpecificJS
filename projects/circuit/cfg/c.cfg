### pad ###

pad $ | $\n | $\t | // ($\n! & @)* $\n | /$* (/$*! & @)* $*/;

### num ###
float {0-9* $. 0-9+}:[float "."];
int 0-9+:[int "."];
oct {0 0-7*}:[oct "."];
hex {0 (x|X) (a-f|A-F|0-9)+:"."}:[hex "."];
sci {float.1 (e|E) ($+ | $- | []:"") int.1}:[float "."];
num {sci | float | hex | oct | int}:(act .);

### var ###

car a-z | A-Z | _;
word {car (car | 0-9)*}:".0 .1";
var word:(act var .);

### lvl1 ###
typ1 word:(act type .);
val1
  var | num |
  {$( pad* val16 pad* $)}.2 |
  {$( pad* [$)! & @]* $)}:(act err ".2") |
  {$[ pad* $]}:(act ary) |
  {$[ pad* val16 (pad* , pad* val16).3* $]}:(act ary .2 .3) |
  {$[ pad* ($]! & @)* $]}:(act ary (act err ".2"));

### lvl2 ###
val2 {
  val1 (pad* [
    ($+$+ | $-$-):["post ."] |
    {($. | $-$>) pad* word}:["mem .0" ".2"] |
    {$[ pad* val16 pad* $]}:[sub .2] |
    {$[ pad* ($]! & @)*:(act err ".") $]}:[sub .2] |
    {$( pad* $)}:[fun] |
    {$( pad* val16 [pad* $, pad* val16].3* pad* $)}:[fun .2 .3] |
    {$( pad* [$)! & @]*:(act err ".") $)}:[fun .2]
  ]).1*
} : (stk (act .) .0 .1);

### lvl3 ###
val3
  {($+$+ | $-$- | $+ | $- | $! | $~ | $* | $&) pad* val2}:(act "pre .0" .2) |
  {$( pad* typ1 pad* $) pad* val3}:(act cast .2 .6) |
  {$( pad* [$)! & @]*:(act err ".") $) pad* val3}:(act cast .2 .6) |
  val2;

### lvl5-15 ###
val5 {val3 [pad* ($* | $/ | $%) pad* val3]:["mid .1" .3]*}:(stk (act.) .0 .1);
val6 {val5 [pad* ($+ | $-) pad* val5]:["mid .1" .3]*}:(stk (act.) .0 .1);
val7 {val6 [pad* ($<$< | $>$>) pad* val6]:["mid .1" .3]*}:(stk (act.) .0 .1);
val8 {val7 [pad* $<=$> pad* val7]:["mid .1" .3]*}:(stk (act.) .0 .1);
val9 {val8 [pad* ($< | $<= | $> | $>=) pad* val8]:["mid .1" .3]*}:(stk (act.) .0 .1);
val10 {val9 [pad* (== | $!=) pad* val9]:["mid .1" .3]*}:(stk (act.) .0 .1);
val11 {val10 [pad* $& ($&! & pad*) val10]:["mid .1" .3]*}:(stk (act.) .0 .1);
val12 {val11 [pad* $^ pad* val11]:["mid .1" .3]*}:(stk (act.) .0 .1);
val13 {val12 [pad* $| pad* val12]:["mid .1" .3]*}:(stk (act.) .0 .1);
val14 {val13 [pad* $&$& pad* val13]:["mid .1" .3]*}:(stk (act.) .0 .1);
val15 {val14 [pad* $|$| pad* val14]:["mid .1" .3]*}:(stk (act.) .0 .1);

### lvl16 ###
tern {val15 pad* $? pad* val16 pad* $: pad* val16}:(act tern .0 .4 .8);
assignop {($+ | $- | $* | $/ | $% | $<$< | $>$> | $& | $^ | $|) =}:"mid .0";
compassi (val15 pad* assignop pad* val16):(act assign .0 (act .2 .0 .4));
assign {val15 pad* = pad* val16}:(act assign .0 .4);
val16 tern | compassi | assign | val15;

### lvl17 ###
wordef {word pad* = pad* val16}:(act wordassign .0 .4) | word:(act wordef .0);
vardef {typ1 pad+ wordef (pad* , pad* wordef).3* pad* $;}:(act vardef .0 .2 .3);
valist
  {val16 (pad* , pad* val16).3+ pad* $;}:(act scope .0 .1) |
  {val16 pad* $;}.0;
ifop { if pad* $( pad* val16 pad* $) pad* val17b }:(act if .4 .8);
elseop { ifop pad* else pad* val17b }:(act else .0 .4);
whileop { while pad* $( pad* val16 pad* $) pad* val17b }:(act while .4 .8);
forop {
  for pad* $( pad* [
    valist | vardef | empty
  ] pad* val16 pad* $; pad* [
    {val16 (pad* , pad* val16).3+ pad* $)}:(act scope .0 .1) |
    {val16 pad* $)}.0 |
    [{$)! & @}* $)]:(act err ".0")
  ] pad* val17b
} : (act scope (act for .4 .6 .10 .12));
loop elseop | ifop | whileop | forop;
block {
  ${
  [pad* ($}! & [val17 | ([$}! & $;! & @]* $;):(act err ".0")])].1*
  pad*
  [$}:[] | ([$}! & @]* $}):(act err ".0")]
}:(act scope .1 .3);
empty $;:(act scope);
val17 block | loop | vardef | valist | empty;
val17b block | loop | valist | empty | staterr;

### start ###
staterr {[$;! & @]* $;}:(act err ".0");

start {
  pad* val17 |
  pad* staterr
}.1*:(act scope .);
